/// <reference types="./otpauth.d.ts" />
const H=o=>{const e=new ArrayBuffer(8),t=new Uint8Array(e);let r=o;for(let s=7;s>=0&&r!==0;s--)t[s]=r&255,r-=t[s],r/=256;return e},K=void 0,J=void 0,N=void 0;var m=Object.freeze({__proto__:null,createHmac:void 0,randomBytes:void 0,timingSafeEqual:void 0});const c=(()=>{if(typeof globalThis=="object")return globalThis;Object.defineProperty(Object.prototype,"__GLOBALTHIS__",{get(){return this},configurable:!0});try{if(typeof __GLOBALTHIS__!="undefined")return __GLOBALTHIS__}finally{delete Object.prototype.__GLOBALTHIS__}if(typeof self!="undefined")return self;if(typeof window!="undefined")return window;if(typeof global!="undefined")return global})();var T=(o,e,t)=>new Promise((r,s)=>{var i=l=>{try{n(t.next(l))}catch(u){s(u)}},a=l=>{try{n(t.throw(l))}catch(u){s(u)}},n=l=>l.done?r(l.value):Promise.resolve(l.value).then(i,a);n((t=t.apply(o,e)).next())});const E={SHA1:"SHA-1",SHA224:"SHA-224",SHA256:"SHA-256",SHA384:"SHA-384",SHA512:"SHA-512","SHA3-224":"SHA3-224","SHA3-256":"SHA3-256","SHA3-384":"SHA3-384","SHA3-512":"SHA3-512"},L=(o,e,t)=>T(void 0,null,function*(){var r,s;m!=null;const i=E[o.toUpperCase()];if(typeof i=="undefined")throw new TypeError("Unknown hash function");if((s=(r=c)==null?void 0:r.crypto)!=null&&s.subtle){const a=c.crypto,n={name:"HMAC",hash:i},l=yield a.subtle.importKey("raw",e,n,!1,["sign"]);return yield a.subtle.sign(n,l,t)}else throw new Error("a")}),w="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",U=o=>{let e=o.length;for(;o[e-1]==="=";)--e;const t=(e<o.length?o.substring(0,e):o).toUpperCase(),r=new ArrayBuffer(t.length*5/8|0),s=new Uint8Array(r);let i=0,a=0,n=0;for(let l=0;l<t.length;l++){const u=w.indexOf(t[l]);if(u===-1)throw new TypeError(`Invalid character found: ${t[l]}`);a=a<<5|u,i+=5,i>=8&&(i-=8,s[n++]=a>>>i)}return r},B=o=>{const e=new Uint8Array(o);let t=0,r=0,s="";for(let i=0;i<e.length;i++)for(r=r<<8|e[i],t+=8;t>=5;)s+=w[r>>>t-5&31],t-=5;return t>0&&(s+=w[r<<5-t&31]),s},O=o=>{const e=new ArrayBuffer(o.length/2),t=new Uint8Array(e);for(let r=0;r<o.length;r+=2)t[r/2]=parseInt(o.substring(r,r+2),16);return e},P=o=>{const e=new Uint8Array(o);let t="";for(let r=0;r<e.length;r++){const s=e[r].toString(16);s.length===1&&(t+="0"),t+=s}return t.toUpperCase()},C=o=>{const e=new ArrayBuffer(o.length),t=new Uint8Array(e);for(let r=0;r<o.length;r++)t[r]=o.charCodeAt(r)&255;return e},x=o=>{const e=new Uint8Array(o);let t="";for(let r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},b=c.TextEncoder?new c.TextEncoder("utf-8"):null,A=c.TextDecoder?new c.TextDecoder("utf-8"):null,j=o=>{if(!b)throw new Error("Encoding API not available");return b.encode(o).buffer},R=o=>{if(!A)throw new Error("Encoding API not available");return A.decode(o)},k=o=>{var e;if(m!=null,!((e=c.crypto)!=null&&e.getRandomValues))throw new Error("Cryptography API not available");return c.crypto.getRandomValues(new Uint8Array(o)).buffer};class h{constructor({buffer:e,size:t=20}={}){this.buffer=typeof e=="undefined"?k(t):e}static fromLatin1(e){return new h({buffer:C(e)})}static fromUTF8(e){return new h({buffer:j(e)})}static fromBase32(e){return new h({buffer:U(e)})}static fromHex(e){return new h({buffer:O(e)})}get latin1(){return Object.defineProperty(this,"latin1",{enumerable:!0,value:x(this.buffer)}),this.latin1}get utf8(){return Object.defineProperty(this,"utf8",{enumerable:!0,value:R(this.buffer)}),this.utf8}get base32(){return Object.defineProperty(this,"base32",{enumerable:!0,value:B(this.buffer)}),this.base32}get hex(){return Object.defineProperty(this,"hex",{enumerable:!0,value:P(this.buffer)}),this.hex}}const M=(o,e)=>{m!=null;{if(o.length!==e.length)throw new TypeError("Input strings must have the same length");let t=-1,r=0;for(;++t<o.length;)r|=o.charCodeAt(t)^e.charCodeAt(t);return r===0}};var D=Math.pow,$=(o,e,t)=>new Promise((r,s)=>{var i=l=>{try{n(t.next(l))}catch(u){s(u)}},a=l=>{try{n(t.throw(l))}catch(u){s(u)}},n=l=>l.done?r(l.value):Promise.resolve(l.value).then(i,a);n((t=t.apply(o,e)).next())});let g=class f{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,counter:0,window:1}}constructor({issuer:e=f.defaults.issuer,label:t=f.defaults.label,issuerInLabel:r=f.defaults.issuerInLabel,secret:s=new h,algorithm:i=f.defaults.algorithm,digits:a=f.defaults.digits,counter:n=f.defaults.counter}={}){this.issuer=e,this.label=t,this.issuerInLabel=r,this.secret=typeof s=="string"?h.fromBase32(s):s,this.algorithm=i.toUpperCase(),this.digits=a,this.counter=n}static generate(e){return $(this,arguments,function*({secret:t,algorithm:r=f.defaults.algorithm,digits:s=f.defaults.digits,counter:i=f.defaults.counter}){const a=new Uint8Array(yield L(r,t.buffer,H(i))),n=a[a.byteLength-1]&15;return(((a[n]&127)<<24|(a[n+1]&255)<<16|(a[n+2]&255)<<8|a[n+3]&255)%D(10,s)).toString().padStart(s,"0")})}generate({counter:e=this.counter++}={}){return f.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:e})}static validate(e){return $(this,arguments,function*({token:t,secret:r,algorithm:s,digits:i,counter:a=f.defaults.counter,window:n=f.defaults.window}){if(t.length!==i)return null;let l=null;for(let u=a-n;u<=a+n;++u){const p=yield f.generate({secret:r,algorithm:s,digits:i,counter:u});M(t,p)&&(l=u-a)}return l})}validate({token:e,counter:t=this.counter,window:r}){return f.validate({token:e,secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:t,window:r})}toString(){const e=encodeURIComponent;return`otpauth://hotp/${this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`}secret=${e(this.secret.base32)}&algorithm=${e(this.algorithm)}&digits=${e(this.digits)}&counter=${e(this.counter)}`}};class d{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,period:30,window:1}}constructor({issuer:e=d.defaults.issuer,label:t=d.defaults.label,issuerInLabel:r=d.defaults.issuerInLabel,secret:s=new h,algorithm:i=d.defaults.algorithm,digits:a=d.defaults.digits,period:n=d.defaults.period}={}){this.issuer=e,this.label=t,this.issuerInLabel=r,this.secret=typeof s=="string"?h.fromBase32(s):s,this.algorithm=i.toUpperCase(),this.digits=a,this.period=n}static generate({secret:e,algorithm:t,digits:r,period:s=d.defaults.period,timestamp:i=Date.now()}){return g.generate({secret:e,algorithm:t,digits:r,counter:Math.floor(i/1e3/s)})}generate({timestamp:e=Date.now()}={}){return d.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:e})}static validate({token:e,secret:t,algorithm:r,digits:s,period:i=d.defaults.period,timestamp:a=Date.now(),window:n}){return g.validate({token:e,secret:t,algorithm:r,digits:s,counter:Math.floor(a/1e3/i),window:n})}validate({token:e,timestamp:t,window:r}){return d.validate({token:e,secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:t,window:r})}toString(){const e=encodeURIComponent;return`otpauth://totp/${this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`}secret=${e(this.secret.base32)}&algorithm=${e(this.algorithm)}&digits=${e(this.digits)}&period=${e(this.period)}`}}const q=/^otpauth:\/\/([ht]otp)\/(.+)\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i,G=/^[2-7A-Z]+=*$/i,Z=/^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i,V=/^[+-]?\d+$/,v=/^\+?[1-9]\d*$/;class z{static parse(e){let t;try{t=e.match(q)}catch(l){}if(!Array.isArray(t))throw new URIError("Invalid URI format");const r=t[1].toLowerCase(),s=t[2].split(/(?::|%3A) *(.+)/i,2).map(decodeURIComponent),i=t[3].split("&").reduce((l,u)=>{const p=u.split(/=(.*)/,2).map(decodeURIComponent),S=p[0].toLowerCase(),I=p[1],y=l;return y[S]=I,y},{});let a;const n={};if(r==="hotp")if(a=g,typeof i.counter!="undefined"&&V.test(i.counter))n.counter=parseInt(i.counter,10);else throw new TypeError("Missing or invalid 'counter' parameter");else if(r==="totp"){if(a=d,typeof i.period!="undefined")if(v.test(i.period))n.period=parseInt(i.period,10);else throw new TypeError("Invalid 'period' parameter")}else throw new TypeError("Unknown OTP type");if(typeof i.issuer!="undefined"&&(n.issuer=i.issuer),s.length===2?(n.label=s[1],typeof n.issuer=="undefined"||n.issuer===""?n.issuer=s[0]:s[0]===""&&(n.issuerInLabel=!1)):(n.label=s[0],typeof n.issuer!="undefined"&&n.issuer!==""&&(n.issuerInLabel=!1)),typeof i.secret!="undefined"&&G.test(i.secret))n.secret=i.secret;else throw new TypeError("Missing or invalid 'secret' parameter");if(typeof i.algorithm!="undefined")if(Z.test(i.algorithm))n.algorithm=i.algorithm;else throw new TypeError("Invalid 'algorithm' parameter");if(typeof i.digits!="undefined")if(v.test(i.digits))n.digits=parseInt(i.digits,10);else throw new TypeError("Invalid 'digits' parameter");return new a(n)}static stringify(e){if(e instanceof g||e instanceof d)return e.toString();throw new TypeError("Invalid 'HOTP/TOTP' object")}}const F="9.2.2";export{g as HOTP,h as Secret,d as TOTP,z as URI,F as version};
//# sourceMappingURL=otpauth.esm.min.js.map
