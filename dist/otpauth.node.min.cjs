/// <reference types="./otpauth.d.ts" />
"use strict";var H=require("node:crypto");function T(i){var e=Object.create(null);return i&&Object.keys(i).forEach(function(t){if(t!=="default"){var r=Object.getOwnPropertyDescriptor(i,t);Object.defineProperty(e,t,r.get?r:{enumerable:!0,get:function(){return i[t]}})}}),e.default=i,Object.freeze(e)}var g=T(H);const O=i=>{const e=new ArrayBuffer(8),t=new Uint8Array(e);let r=i;for(let n=7;n>=0&&r!==0;n--)t[n]=r&255,r-=t[n],r/=256;return e},c=(()=>{if(typeof globalThis=="object")return globalThis;Object.defineProperty(Object.prototype,"__GLOBALTHIS__",{get(){return this},configurable:!0});try{if(typeof __GLOBALTHIS__!="undefined")return __GLOBALTHIS__}finally{delete Object.prototype.__GLOBALTHIS__}if(typeof self!="undefined")return self;if(typeof window!="undefined")return window;if(typeof global!="undefined")return global})();var L=(i,e,t)=>new Promise((r,n)=>{var s=l=>{try{o(t.next(l))}catch(u){n(u)}},a=l=>{try{o(t.throw(l))}catch(u){n(u)}},o=l=>l.done?r(l.value):Promise.resolve(l.value).then(s,a);o((t=t.apply(i,e)).next())});const U={SHA1:"SHA-1",SHA224:"SHA-224",SHA256:"SHA-256",SHA384:"SHA-384",SHA512:"SHA-512","SHA3-224":"SHA3-224","SHA3-256":"SHA3-256","SHA3-384":"SHA3-384","SHA3-512":"SHA3-512"},E=(i,e,t)=>L(void 0,null,function*(){var r,n;if(g!=null&&g.createHmac){const a=g.createHmac(i,c.Buffer.from(e));return a.update(c.Buffer.from(t)),a.digest().buffer}const s=U[i.toUpperCase()];if(typeof s=="undefined")throw new TypeError("Unknown hash function");if((n=(r=c)==null?void 0:r.crypto)!=null&&n.subtle){const a=c.crypto,o={name:"HMAC",hash:s},l=yield a.subtle.importKey("raw",e,o,!1,["sign"]);return yield a.subtle.sign(o,l,t)}else throw new Error("a")}),w="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",P=i=>{let e=i.length;for(;i[e-1]==="=";)--e;const t=(e<i.length?i.substring(0,e):i).toUpperCase(),r=new ArrayBuffer(t.length*5/8|0),n=new Uint8Array(r);let s=0,a=0,o=0;for(let l=0;l<t.length;l++){const u=w.indexOf(t[l]);if(u===-1)throw new TypeError(`Invalid character found: ${t[l]}`);a=a<<5|u,s+=5,s>=8&&(s-=8,n[o++]=a>>>s)}return r},C=i=>{const e=new Uint8Array(i);let t=0,r=0,n="";for(let s=0;s<e.length;s++)for(r=r<<8|e[s],t+=8;t>=5;)n+=w[r>>>t-5&31],t-=5;return t>0&&(n+=w[r<<5-t&31]),n},B=i=>{const e=new ArrayBuffer(i.length/2),t=new Uint8Array(e);for(let r=0;r<i.length;r+=2)t[r/2]=parseInt(i.substring(r,r+2),16);return e},j=i=>{const e=new Uint8Array(i);let t="";for(let r=0;r<e.length;r++){const n=e[r].toString(16);n.length===1&&(t+="0"),t+=n}return t.toUpperCase()},x=i=>{const e=new ArrayBuffer(i.length),t=new Uint8Array(e);for(let r=0;r<i.length;r++)t[r]=i.charCodeAt(r)&255;return e},R=i=>{const e=new Uint8Array(i);let t="";for(let r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},y=c.TextEncoder?new c.TextEncoder("utf-8"):null,A=c.TextDecoder?new c.TextDecoder("utf-8"):null,D=i=>{if(!y)throw new Error("Encoding API not available");return y.encode(i).buffer},k=i=>{if(!A)throw new Error("Encoding API not available");return A.decode(i)},M=i=>{var e;if(g!=null&&g.randomBytes)return g.randomBytes(i).buffer;if(!((e=c.crypto)!=null&&e.getRandomValues))throw new Error("Cryptography API not available");return c.crypto.getRandomValues(new Uint8Array(i)).buffer};class d{constructor({buffer:e,size:t=20}={}){this.buffer=typeof e=="undefined"?M(t):e}static fromLatin1(e){return new d({buffer:x(e)})}static fromUTF8(e){return new d({buffer:D(e)})}static fromBase32(e){return new d({buffer:P(e)})}static fromHex(e){return new d({buffer:B(e)})}get latin1(){return Object.defineProperty(this,"latin1",{enumerable:!0,value:R(this.buffer)}),this.latin1}get utf8(){return Object.defineProperty(this,"utf8",{enumerable:!0,value:k(this.buffer)}),this.utf8}get base32(){return Object.defineProperty(this,"base32",{enumerable:!0,value:C(this.buffer)}),this.base32}get hex(){return Object.defineProperty(this,"hex",{enumerable:!0,value:j(this.buffer)}),this.hex}}const G=(i,e)=>{if(g!=null&&g.timingSafeEqual)return g.timingSafeEqual(c.Buffer.from(i),c.Buffer.from(e));{if(i.length!==e.length)throw new TypeError("Input strings must have the same length");let t=-1,r=0;for(;++t<i.length;)r|=i.charCodeAt(t)^e.charCodeAt(t);return r===0}};var Z=Math.pow,v=(i,e,t)=>new Promise((r,n)=>{var s=l=>{try{o(t.next(l))}catch(u){n(u)}},a=l=>{try{o(t.throw(l))}catch(u){n(u)}},o=l=>l.done?r(l.value):Promise.resolve(l.value).then(s,a);o((t=t.apply(i,e)).next())});let p=class f{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,counter:0,window:1}}constructor({issuer:e=f.defaults.issuer,label:t=f.defaults.label,issuerInLabel:r=f.defaults.issuerInLabel,secret:n=new d,algorithm:s=f.defaults.algorithm,digits:a=f.defaults.digits,counter:o=f.defaults.counter}={}){this.issuer=e,this.label=t,this.issuerInLabel=r,this.secret=typeof n=="string"?d.fromBase32(n):n,this.algorithm=s.toUpperCase(),this.digits=a,this.counter=o}static generate(e){return v(this,arguments,function*({secret:t,algorithm:r=f.defaults.algorithm,digits:n=f.defaults.digits,counter:s=f.defaults.counter}){const a=new Uint8Array(yield E(r,t.buffer,O(s))),o=a[a.byteLength-1]&15;return(((a[o]&127)<<24|(a[o+1]&255)<<16|(a[o+2]&255)<<8|a[o+3]&255)%Z(10,n)).toString().padStart(n,"0")})}generate({counter:e=this.counter++}={}){return f.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:e})}static validate(e){return v(this,arguments,function*({token:t,secret:r,algorithm:n,digits:s,counter:a=f.defaults.counter,window:o=f.defaults.window}){if(t.length!==s)return null;let l=null;for(let u=a-o;u<=a+o;++u){const m=yield f.generate({secret:r,algorithm:n,digits:s,counter:u});G(t,m)&&(l=u-a)}return l})}validate({token:e,counter:t=this.counter,window:r}){return f.validate({token:e,secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:t,window:r})}toString(){const e=encodeURIComponent;return`otpauth://hotp/${this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`}secret=${e(this.secret.base32)}&algorithm=${e(this.algorithm)}&digits=${e(this.digits)}&counter=${e(this.counter)}`}};class h{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,period:30,window:1}}constructor({issuer:e=h.defaults.issuer,label:t=h.defaults.label,issuerInLabel:r=h.defaults.issuerInLabel,secret:n=new d,algorithm:s=h.defaults.algorithm,digits:a=h.defaults.digits,period:o=h.defaults.period}={}){this.issuer=e,this.label=t,this.issuerInLabel=r,this.secret=typeof n=="string"?d.fromBase32(n):n,this.algorithm=s.toUpperCase(),this.digits=a,this.period=o}static generate({secret:e,algorithm:t,digits:r,period:n=h.defaults.period,timestamp:s=Date.now()}){return p.generate({secret:e,algorithm:t,digits:r,counter:Math.floor(s/1e3/n)})}generate({timestamp:e=Date.now()}={}){return h.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:e})}static validate({token:e,secret:t,algorithm:r,digits:n,period:s=h.defaults.period,timestamp:a=Date.now(),window:o}){return p.validate({token:e,secret:t,algorithm:r,digits:n,counter:Math.floor(a/1e3/s),window:o})}validate({token:e,timestamp:t,window:r}){return h.validate({token:e,secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:t,window:r})}toString(){const e=encodeURIComponent;return`otpauth://totp/${this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`}secret=${e(this.secret.base32)}&algorithm=${e(this.algorithm)}&digits=${e(this.digits)}&period=${e(this.period)}`}}const q=/^otpauth:\/\/([ht]otp)\/(.+)\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i,V=/^[2-7A-Z]+=*$/i,z=/^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i,F=/^[+-]?\d+$/,$=/^\+?[1-9]\d*$/;class K{static parse(e){let t;try{t=e.match(q)}catch(l){}if(!Array.isArray(t))throw new URIError("Invalid URI format");const r=t[1].toLowerCase(),n=t[2].split(/(?::|%3A) *(.+)/i,2).map(decodeURIComponent),s=t[3].split("&").reduce((l,u)=>{const m=u.split(/=(.*)/,2).map(decodeURIComponent),I=m[0].toLowerCase(),S=m[1],b=l;return b[I]=S,b},{});let a;const o={};if(r==="hotp")if(a=p,typeof s.counter!="undefined"&&F.test(s.counter))o.counter=parseInt(s.counter,10);else throw new TypeError("Missing or invalid 'counter' parameter");else if(r==="totp"){if(a=h,typeof s.period!="undefined")if($.test(s.period))o.period=parseInt(s.period,10);else throw new TypeError("Invalid 'period' parameter")}else throw new TypeError("Unknown OTP type");if(typeof s.issuer!="undefined"&&(o.issuer=s.issuer),n.length===2?(o.label=n[1],typeof o.issuer=="undefined"||o.issuer===""?o.issuer=n[0]:n[0]===""&&(o.issuerInLabel=!1)):(o.label=n[0],typeof o.issuer!="undefined"&&o.issuer!==""&&(o.issuerInLabel=!1)),typeof s.secret!="undefined"&&V.test(s.secret))o.secret=s.secret;else throw new TypeError("Missing or invalid 'secret' parameter");if(typeof s.algorithm!="undefined")if(z.test(s.algorithm))o.algorithm=s.algorithm;else throw new TypeError("Invalid 'algorithm' parameter");if(typeof s.digits!="undefined")if($.test(s.digits))o.digits=parseInt(s.digits,10);else throw new TypeError("Invalid 'digits' parameter");return new a(o)}static stringify(e){if(e instanceof p||e instanceof h)return e.toString();throw new TypeError("Invalid 'HOTP/TOTP' object")}}const N="9.2.2";exports.HOTP=p,exports.Secret=d,exports.TOTP=h,exports.URI=K,exports.version=N;
//# sourceMappingURL=otpauth.node.min.cjs.map
