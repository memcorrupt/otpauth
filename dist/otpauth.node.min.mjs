/// <reference types="./otpauth.d.ts" />
import*as g from"node:crypto";const H=o=>{const e=new ArrayBuffer(8),t=new Uint8Array(e);let r=o;for(let s=7;s>=0&&r!==0;s--)t[s]=r&255,r-=t[s],r/=256;return e};var T=void 0;const d=(()=>{if(typeof globalThis=="object")return globalThis;Object.defineProperty(Object.prototype,"__GLOBALTHIS__",{get(){return this},configurable:!0});try{if(typeof __GLOBALTHIS__!="undefined")return __GLOBALTHIS__}finally{delete Object.prototype.__GLOBALTHIS__}if(typeof self!="undefined")return self;if(typeof window!="undefined")return window;if(typeof global!="undefined")return global})();var U=(o,e,t)=>new Promise((r,s)=>{var i=l=>{try{n(t.next(l))}catch(u){s(u)}},a=l=>{try{n(t.throw(l))}catch(u){s(u)}},n=l=>l.done?r(l.value):Promise.resolve(l.value).then(i,a);n((t=t.apply(o,e)).next())});const E={SHA1:"SHA-1",SHA224:"SHA-224",SHA256:"SHA-256",SHA384:"SHA-384",SHA512:"SHA-512","SHA3-224":"SHA3-224","SHA3-256":"SHA3-256","SHA3-384":"SHA3-384","SHA3-512":"SHA3-512"},L=(o,e,t)=>U(void 0,null,function*(){var r,s;if(g!=null&&g.createHmac){const a=g.createHmac(o,d.Buffer.from(e));return a.update(d.Buffer.from(t)),a.digest().buffer}const i=E[o.toUpperCase()];if(typeof i=="undefined")throw new TypeError("Unknown hash function");if((s=(r=d)==null?void 0:r.crypto)!=null&&s.subtle){const a=d.crypto,n={name:"HMAC",hash:i},l=yield a.subtle.importKey("raw",e,n,!1,["sign"]);return yield a.subtle.sign(n,l,t)}else{const a=new T(i,"ARRAYBUFFER");return a.setHMACKey(e,"ARRAYBUFFER"),a.update(t),a.getHMAC("ARRAYBUFFER")}}),w="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",B=o=>{let e=o.length;for(;o[e-1]==="=";)--e;const t=(e<o.length?o.substring(0,e):o).toUpperCase(),r=new ArrayBuffer(t.length*5/8|0),s=new Uint8Array(r);let i=0,a=0,n=0;for(let l=0;l<t.length;l++){const u=w.indexOf(t[l]);if(u===-1)throw new TypeError(`Invalid character found: ${t[l]}`);a=a<<5|u,i+=5,i>=8&&(i-=8,s[n++]=a>>>i)}return r},C=o=>{const e=new Uint8Array(o);let t=0,r=0,s="";for(let i=0;i<e.length;i++)for(r=r<<8|e[i],t+=8;t>=5;)s+=w[r>>>t-5&31],t-=5;return t>0&&(s+=w[r<<5-t&31]),s},O=o=>{const e=new ArrayBuffer(o.length/2),t=new Uint8Array(e);for(let r=0;r<o.length;r+=2)t[r/2]=parseInt(o.substring(r,r+2),16);return e},P=o=>{const e=new Uint8Array(o);let t="";for(let r=0;r<e.length;r++){const s=e[r].toString(16);s.length===1&&(t+="0"),t+=s}return t.toUpperCase()},R=o=>{const e=new ArrayBuffer(o.length),t=new Uint8Array(e);for(let r=0;r<o.length;r++)t[r]=o.charCodeAt(r)&255;return e},x=o=>{const e=new Uint8Array(o);let t="";for(let r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},b=d.TextEncoder?new d.TextEncoder("utf-8"):null,A=d.TextDecoder?new d.TextDecoder("utf-8"):null,j=o=>{if(!b)throw new Error("Encoding API not available");return b.encode(o).buffer},k=o=>{if(!A)throw new Error("Encoding API not available");return A.decode(o)},M=o=>{var e;if(g!=null&&g.randomBytes)return g.randomBytes(o).buffer;if(!((e=d.crypto)!=null&&e.getRandomValues))throw new Error("Cryptography API not available");return d.crypto.getRandomValues(new Uint8Array(o)).buffer};class c{constructor({buffer:e,size:t=20}={}){this.buffer=typeof e=="undefined"?M(t):e}static fromLatin1(e){return new c({buffer:R(e)})}static fromUTF8(e){return new c({buffer:j(e)})}static fromBase32(e){return new c({buffer:B(e)})}static fromHex(e){return new c({buffer:O(e)})}get latin1(){return Object.defineProperty(this,"latin1",{enumerable:!0,value:x(this.buffer)}),this.latin1}get utf8(){return Object.defineProperty(this,"utf8",{enumerable:!0,value:k(this.buffer)}),this.utf8}get base32(){return Object.defineProperty(this,"base32",{enumerable:!0,value:C(this.buffer)}),this.base32}get hex(){return Object.defineProperty(this,"hex",{enumerable:!0,value:P(this.buffer)}),this.hex}}const F=(o,e)=>{if(g!=null&&g.timingSafeEqual)return g.timingSafeEqual(d.Buffer.from(o),d.Buffer.from(e));{if(o.length!==e.length)throw new TypeError("Input strings must have the same length");let t=-1,r=0;for(;++t<o.length;)r|=o.charCodeAt(t)^e.charCodeAt(t);return r===0}};var D=Math.pow,$=(o,e,t)=>new Promise((r,s)=>{var i=l=>{try{n(t.next(l))}catch(u){s(u)}},a=l=>{try{n(t.throw(l))}catch(u){s(u)}},n=l=>l.done?r(l.value):Promise.resolve(l.value).then(i,a);n((t=t.apply(o,e)).next())});let p=class f{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,counter:0,window:1}}constructor({issuer:e=f.defaults.issuer,label:t=f.defaults.label,issuerInLabel:r=f.defaults.issuerInLabel,secret:s=new c,algorithm:i=f.defaults.algorithm,digits:a=f.defaults.digits,counter:n=f.defaults.counter}={}){this.issuer=e,this.label=t,this.issuerInLabel=r,this.secret=typeof s=="string"?c.fromBase32(s):s,this.algorithm=i.toUpperCase(),this.digits=a,this.counter=n}static generate(e){return $(this,arguments,function*({secret:t,algorithm:r=f.defaults.algorithm,digits:s=f.defaults.digits,counter:i=f.defaults.counter}){const a=new Uint8Array(yield L(r,t.buffer,H(i))),n=a[a.byteLength-1]&15;return(((a[n]&127)<<24|(a[n+1]&255)<<16|(a[n+2]&255)<<8|a[n+3]&255)%D(10,s)).toString().padStart(s,"0")})}generate({counter:e=this.counter++}={}){return f.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:e})}static validate(e){return $(this,arguments,function*({token:t,secret:r,algorithm:s,digits:i,counter:a=f.defaults.counter,window:n=f.defaults.window}){if(t.length!==i)return null;let l=null;for(let u=a-n;u<=a+n;++u){const m=yield f.generate({secret:r,algorithm:s,digits:i,counter:u});F(t,m)&&(l=u-a)}return l})}validate({token:e,counter:t=this.counter,window:r}){return f.validate({token:e,secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:t,window:r})}toString(){const e=encodeURIComponent;return`otpauth://hotp/${this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`}secret=${e(this.secret.base32)}&algorithm=${e(this.algorithm)}&digits=${e(this.digits)}&counter=${e(this.counter)}`}};class h{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,period:30,window:1}}constructor({issuer:e=h.defaults.issuer,label:t=h.defaults.label,issuerInLabel:r=h.defaults.issuerInLabel,secret:s=new c,algorithm:i=h.defaults.algorithm,digits:a=h.defaults.digits,period:n=h.defaults.period}={}){this.issuer=e,this.label=t,this.issuerInLabel=r,this.secret=typeof s=="string"?c.fromBase32(s):s,this.algorithm=i.toUpperCase(),this.digits=a,this.period=n}static generate({secret:e,algorithm:t,digits:r,period:s=h.defaults.period,timestamp:i=Date.now()}){return p.generate({secret:e,algorithm:t,digits:r,counter:Math.floor(i/1e3/s)})}generate({timestamp:e=Date.now()}={}){return h.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:e})}static validate({token:e,secret:t,algorithm:r,digits:s,period:i=h.defaults.period,timestamp:a=Date.now(),window:n}){return p.validate({token:e,secret:t,algorithm:r,digits:s,counter:Math.floor(a/1e3/i),window:n})}validate({token:e,timestamp:t,window:r}){return h.validate({token:e,secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:t,window:r})}toString(){const e=encodeURIComponent;return`otpauth://totp/${this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`}secret=${e(this.secret.base32)}&algorithm=${e(this.algorithm)}&digits=${e(this.digits)}&period=${e(this.period)}`}}const G=/^otpauth:\/\/([ht]otp)\/(.+)\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i,Y=/^[2-7A-Z]+=*$/i,Z=/^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i,K=/^[+-]?\d+$/,v=/^\+?[1-9]\d*$/;class V{static parse(e){let t;try{t=e.match(G)}catch(l){}if(!Array.isArray(t))throw new URIError("Invalid URI format");const r=t[1].toLowerCase(),s=t[2].split(/(?::|%3A) *(.+)/i,2).map(decodeURIComponent),i=t[3].split("&").reduce((l,u)=>{const m=u.split(/=(.*)/,2).map(decodeURIComponent),I=m[0].toLowerCase(),S=m[1],y=l;return y[I]=S,y},{});let a;const n={};if(r==="hotp")if(a=p,typeof i.counter!="undefined"&&K.test(i.counter))n.counter=parseInt(i.counter,10);else throw new TypeError("Missing or invalid 'counter' parameter");else if(r==="totp"){if(a=h,typeof i.period!="undefined")if(v.test(i.period))n.period=parseInt(i.period,10);else throw new TypeError("Invalid 'period' parameter")}else throw new TypeError("Unknown OTP type");if(typeof i.issuer!="undefined"&&(n.issuer=i.issuer),s.length===2?(n.label=s[1],typeof n.issuer=="undefined"||n.issuer===""?n.issuer=s[0]:s[0]===""&&(n.issuerInLabel=!1)):(n.label=s[0],typeof n.issuer!="undefined"&&n.issuer!==""&&(n.issuerInLabel=!1)),typeof i.secret!="undefined"&&Y.test(i.secret))n.secret=i.secret;else throw new TypeError("Missing or invalid 'secret' parameter");if(typeof i.algorithm!="undefined")if(Z.test(i.algorithm))n.algorithm=i.algorithm;else throw new TypeError("Invalid 'algorithm' parameter");if(typeof i.digits!="undefined")if(v.test(i.digits))n.digits=parseInt(i.digits,10);else throw new TypeError("Invalid 'digits' parameter");return new a(n)}static stringify(e){if(e instanceof p||e instanceof h)return e.toString();throw new TypeError("Invalid 'HOTP/TOTP' object")}}const q="9.2.2";export{p as HOTP,c as Secret,h as TOTP,V as URI,q as version};
//# sourceMappingURL=otpauth.node.min.mjs.map
