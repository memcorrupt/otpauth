{"version":3,"file":"otpauth.node.min.mjs","sources":["../src/utils/encoding/uint.js","../src/utils/global-scope.js","../src/utils/crypto/hmac-digest.js","../src/utils/encoding/base32.js","../src/utils/encoding/hex.js","../src/utils/encoding/latin1.js","../src/utils/encoding/utf8.js","../src/utils/crypto/random-bytes.js","../src/secret.js","../src/utils/crypto/timing-safe-equal.js","../src/hotp.js","../src/totp.js","../src/uri.js","../src/version.js"],"sourcesContent":["/**\n * Converts an integer to an ArrayBuffer.\n * @param {number} num Integer.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nconst uintToBuf = (num) => {\n  const buf = new ArrayBuffer(8);\n  const arr = new Uint8Array(buf);\n  let acc = num;\n\n  for (let i = 7; i >= 0; i--) {\n    if (acc === 0) break;\n    arr[i] = acc & 255;\n    acc -= arr[i];\n    acc /= 256;\n  }\n\n  return buf;\n};\n\n/**\n * Converts an ArrayBuffer to an integer.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {number} Integer.\n */\nconst uintFromBuf = (buf) => {\n  const arr = new Uint8Array(buf);\n  let num = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] !== 0) {\n      num *= 256;\n      num += arr[i];\n    }\n  }\n\n  return num;\n};\n\nexport { uintToBuf, uintFromBuf };\n","/**\n * \"globalThis\" ponyfill.\n * @see [A horrifying globalThis polyfill in universal JavaScript](https://mathiasbynens.be/notes/globalthis)\n * @type {Object.<string, *>}\n */\nconst globalScope = (() => {\n  if (typeof globalThis === \"object\") return globalThis;\n  else {\n    Object.defineProperty(Object.prototype, \"__GLOBALTHIS__\", {\n      get() {\n        return this;\n      },\n      configurable: true,\n    });\n    try {\n      // @ts-ignore\n      // eslint-disable-next-line no-undef\n      if (typeof __GLOBALTHIS__ !== \"undefined\") return __GLOBALTHIS__;\n    } finally {\n      // @ts-ignore\n      delete Object.prototype.__GLOBALTHIS__;\n    }\n  }\n\n  // Still unable to determine \"globalThis\", fall back to a naive method.\n  if (typeof self !== \"undefined\") return self;\n  else if (typeof window !== \"undefined\") return window;\n  else if (typeof global !== \"undefined\") return global;\n\n  return undefined;\n})();\n\nexport { globalScope };\n","import * as crypto from \"node:crypto\";\nimport jsSHA from \"jssha\";\n\nimport { globalScope } from \"../global-scope.js\";\n\n/**\n * OpenSSL to jsSHA algorithms map.\n * @type {Object.<string, \"SHA-1\"|\"SHA-224\"|\"SHA-256\"|\"SHA-384\"|\"SHA-512\"|\"SHA3-224\"|\"SHA3-256\"|\"SHA3-384\"|\"SHA3-512\">}\n */\nconst OPENSSL_JSSHA_ALGO_MAP = {\n  SHA1: \"SHA-1\",\n  SHA224: \"SHA-224\",\n  SHA256: \"SHA-256\",\n  SHA384: \"SHA-384\",\n  SHA512: \"SHA-512\",\n  \"SHA3-224\": \"SHA3-224\",\n  \"SHA3-256\": \"SHA3-256\",\n  \"SHA3-384\": \"SHA3-384\",\n  \"SHA3-512\": \"SHA3-512\",\n};\n\n/**\n * Calculates an HMAC digest.\n * In Node.js, the command \"openssl list -digest-algorithms\" displays the available digest algorithms.\n * @param {string} algorithm Algorithm.\n * @param {ArrayBuffer} key Key.\n * @param {ArrayBuffer} message Message.\n * @returns {Promise<ArrayBuffer>} Digest.\n */\nconst hmacDigest = async (algorithm, key, message) => {\n  if (crypto?.createHmac) {\n    const hmac = crypto.createHmac(algorithm, globalScope.Buffer.from(key));\n    hmac.update(globalScope.Buffer.from(message));\n    return hmac.digest().buffer;\n  }\n\n  const variant = OPENSSL_JSSHA_ALGO_MAP[algorithm.toUpperCase()];\n  if (typeof variant === \"undefined\") {\n    throw new TypeError(\"Unknown hash function\");\n  }\n\n  if (globalScope?.crypto?.subtle) {\n    const crypto = globalScope.crypto;\n\n    const algorithm = {\n      name: \"HMAC\",\n      hash: variant,\n    };\n\n    const hmacKey = await crypto.subtle.importKey(\n      \"raw\",\n      key,\n      algorithm,\n      false,\n      [\"sign\"],\n    );\n\n    return await crypto.subtle.sign(algorithm, hmacKey, message);\n  } else {\n    const hmac = new jsSHA(variant, \"ARRAYBUFFER\");\n    hmac.setHMACKey(key, \"ARRAYBUFFER\");\n    hmac.update(message);\n    return hmac.getHMAC(\"ARRAYBUFFER\");\n  }\n};\n\nexport { hmacDigest };\n","/**\n * RFC 4648 base32 alphabet without pad.\n * @type {string}\n */\nconst ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n\n/**\n * Converts a base32 string to an ArrayBuffer (RFC 4648).\n * @see [LinusU/base32-decode](https://github.com/LinusU/base32-decode)\n * @param {string} str Base32 string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nconst base32ToBuf = (str) => {\n  // Canonicalize to all upper case and remove padding if it exists.\n  let end = str.length;\n  while (str[end - 1] === \"=\") --end;\n  const cstr = (end < str.length ? str.substring(0, end) : str).toUpperCase();\n\n  const buf = new ArrayBuffer(((cstr.length * 5) / 8) | 0);\n  const arr = new Uint8Array(buf);\n  let bits = 0;\n  let value = 0;\n  let index = 0;\n\n  for (let i = 0; i < cstr.length; i++) {\n    const idx = ALPHABET.indexOf(cstr[i]);\n    if (idx === -1) throw new TypeError(`Invalid character found: ${cstr[i]}`);\n\n    value = (value << 5) | idx;\n    bits += 5;\n\n    if (bits >= 8) {\n      bits -= 8;\n      arr[index++] = value >>> bits;\n    }\n  }\n\n  return buf;\n};\n\n/**\n * Converts an ArrayBuffer to a base32 string (RFC 4648).\n * @see [LinusU/base32-encode](https://github.com/LinusU/base32-encode)\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Base32 string.\n */\nconst base32FromBuf = (buf) => {\n  const arr = new Uint8Array(buf);\n  let bits = 0;\n  let value = 0;\n  let str = \"\";\n\n  for (let i = 0; i < arr.length; i++) {\n    value = (value << 8) | arr[i];\n    bits += 8;\n\n    while (bits >= 5) {\n      str += ALPHABET[(value >>> (bits - 5)) & 31];\n      bits -= 5;\n    }\n  }\n\n  if (bits > 0) {\n    str += ALPHABET[(value << (5 - bits)) & 31];\n  }\n\n  return str;\n};\n\nexport { base32ToBuf, base32FromBuf };\n","/**\n * Converts a hexadecimal string to an ArrayBuffer.\n * @param {string} str Hexadecimal string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nconst hexToBuf = (str) => {\n  const buf = new ArrayBuffer(str.length / 2);\n  const arr = new Uint8Array(buf);\n\n  for (let i = 0; i < str.length; i += 2) {\n    arr[i / 2] = parseInt(str.substring(i, i + 2), 16);\n  }\n\n  return buf;\n};\n\n/**\n * Converts an ArrayBuffer to a hexadecimal string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Hexadecimal string.\n */\nconst hexFromBuf = (buf) => {\n  const arr = new Uint8Array(buf);\n  let str = \"\";\n\n  for (let i = 0; i < arr.length; i++) {\n    const hex = arr[i].toString(16);\n    if (hex.length === 1) str += \"0\";\n    str += hex;\n  }\n\n  return str.toUpperCase();\n};\n\nexport { hexToBuf, hexFromBuf };\n","/**\n * Converts a Latin-1 string to an ArrayBuffer.\n * @param {string} str Latin-1 string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nconst latin1ToBuf = (str) => {\n  const buf = new ArrayBuffer(str.length);\n  const arr = new Uint8Array(buf);\n\n  for (let i = 0; i < str.length; i++) {\n    arr[i] = str.charCodeAt(i) & 0xff;\n  }\n\n  return buf;\n};\n\n/**\n * Converts an ArrayBuffer to a Latin-1 string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Latin-1 string.\n */\nconst latin1FromBuf = (buf) => {\n  const arr = new Uint8Array(buf);\n  let str = \"\";\n\n  for (let i = 0; i < arr.length; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n\n  return str;\n};\n\nexport { latin1ToBuf, latin1FromBuf };\n","import { globalScope } from \"../global-scope.js\";\n\n/**\n * TextEncoder instance.\n * @type {TextEncoder|null}\n */\nconst ENCODER = globalScope.TextEncoder\n  ? new globalScope.TextEncoder(\"utf-8\")\n  : null;\n\n/**\n * TextDecoder instance.\n * @type {TextDecoder|null}\n */\nconst DECODER = globalScope.TextDecoder\n  ? new globalScope.TextDecoder(\"utf-8\")\n  : null;\n\n/**\n * Converts an UTF-8 string to an ArrayBuffer.\n * @param {string} str String.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nconst utf8ToBuf = (str) => {\n  if (!ENCODER) {\n    throw new Error(\"Encoding API not available\");\n  }\n\n  return ENCODER.encode(str).buffer;\n};\n\n/**\n * Converts an ArrayBuffer to an UTF-8 string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} String.\n */\nconst utf8FromBuf = (buf) => {\n  if (!DECODER) {\n    throw new Error(\"Encoding API not available\");\n  }\n\n  return DECODER.decode(buf);\n};\n\nexport { utf8ToBuf, utf8FromBuf };\n","import * as crypto from \"node:crypto\";\n\nimport { globalScope } from \"../global-scope.js\";\n\n/**\n * Returns random bytes.\n * @param {number} size Size.\n * @returns {ArrayBuffer} Random bytes.\n */\nconst randomBytes = (size) => {\n  if (crypto?.randomBytes) {\n    return crypto.randomBytes(size).buffer;\n  } else {\n    if (!globalScope.crypto?.getRandomValues) {\n      throw new Error(\"Cryptography API not available\");\n    }\n    return globalScope.crypto.getRandomValues(new Uint8Array(size)).buffer;\n  }\n};\n\nexport { randomBytes };\n","import { base32ToBuf, base32FromBuf } from \"./utils/encoding/base32.js\";\nimport { hexToBuf, hexFromBuf } from \"./utils/encoding/hex.js\";\nimport { latin1ToBuf, latin1FromBuf } from \"./utils/encoding/latin1.js\";\nimport { utf8ToBuf, utf8FromBuf } from \"./utils/encoding/utf8.js\";\nimport { randomBytes } from \"./utils/crypto/random-bytes.js\";\n\n/**\n * OTP secret key.\n */\nclass Secret {\n  /**\n   * Creates a secret key object.\n   * @param {Object} [config] Configuration options.\n   * @param {ArrayBuffer} [config.buffer=randomBytes] Secret key.\n   * @param {number} [config.size=20] Number of random bytes to generate, ignored if 'buffer' is provided.\n   */\n  constructor({ buffer, size = 20 } = {}) {\n    /**\n     * Secret key.\n     * @type {ArrayBuffer}\n     */\n    this.buffer = typeof buffer === \"undefined\" ? randomBytes(size) : buffer;\n  }\n\n  /**\n   * Converts a Latin-1 string to a Secret object.\n   * @param {string} str Latin-1 string.\n   * @returns {Secret} Secret object.\n   */\n  static fromLatin1(str) {\n    return new Secret({ buffer: latin1ToBuf(str) });\n  }\n\n  /**\n   * Converts an UTF-8 string to a Secret object.\n   * @param {string} str UTF-8 string.\n   * @returns {Secret} Secret object.\n   */\n  static fromUTF8(str) {\n    return new Secret({ buffer: utf8ToBuf(str) });\n  }\n\n  /**\n   * Converts a base32 string to a Secret object.\n   * @param {string} str Base32 string.\n   * @returns {Secret} Secret object.\n   */\n  static fromBase32(str) {\n    return new Secret({ buffer: base32ToBuf(str) });\n  }\n\n  /**\n   * Converts a hexadecimal string to a Secret object.\n   * @param {string} str Hexadecimal string.\n   * @returns {Secret} Secret object.\n   */\n  static fromHex(str) {\n    return new Secret({ buffer: hexToBuf(str) });\n  }\n\n  /**\n   * Latin-1 string representation of secret key.\n   * @type {string}\n   */\n  get latin1() {\n    Object.defineProperty(this, \"latin1\", {\n      enumerable: true,\n      value: latin1FromBuf(this.buffer),\n    });\n\n    return this.latin1;\n  }\n\n  /**\n   * UTF-8 string representation of secret key.\n   * @type {string}\n   */\n  get utf8() {\n    Object.defineProperty(this, \"utf8\", {\n      enumerable: true,\n      value: utf8FromBuf(this.buffer),\n    });\n\n    return this.utf8;\n  }\n\n  /**\n   * Base32 string representation of secret key.\n   * @type {string}\n   */\n  get base32() {\n    Object.defineProperty(this, \"base32\", {\n      enumerable: true,\n      value: base32FromBuf(this.buffer),\n    });\n\n    return this.base32;\n  }\n\n  /**\n   * Hexadecimal string representation of secret key.\n   * @type {string}\n   */\n  get hex() {\n    Object.defineProperty(this, \"hex\", {\n      enumerable: true,\n      value: hexFromBuf(this.buffer),\n    });\n\n    return this.hex;\n  }\n}\n\nexport { Secret };\n","import * as crypto from \"node:crypto\";\n\nimport { globalScope } from \"../global-scope.js\";\n\n/**\n * Returns true if a is equal to b, without leaking timing information that would allow an attacker to guess one of the values.\n * @param {string} a String a.\n * @param {string} b String b.\n * @returns {boolean} Equality result.\n */\nconst timingSafeEqual = (a, b) => {\n  if (crypto?.timingSafeEqual) {\n    return crypto.timingSafeEqual(\n      globalScope.Buffer.from(a),\n      globalScope.Buffer.from(b),\n    );\n  } else {\n    if (a.length !== b.length) {\n      throw new TypeError(\"Input strings must have the same length\");\n    }\n    let i = -1;\n    let out = 0;\n    while (++i < a.length) {\n      out |= a.charCodeAt(i) ^ b.charCodeAt(i);\n    }\n    return out === 0;\n  }\n};\n\nexport { timingSafeEqual };\n","import { uintToBuf } from \"./utils/encoding/uint.js\";\nimport { hmacDigest } from \"./utils/crypto/hmac-digest.js\";\nimport { Secret } from \"./secret.js\";\nimport { timingSafeEqual } from \"./utils/crypto/timing-safe-equal.js\";\n\n/**\n * HOTP: An HMAC-based One-time Password Algorithm.\n * @see [RFC 4226](https://tools.ietf.org/html/rfc4226)\n */\nclass HOTP {\n  /**\n   * Default configuration.\n   * @type {{\n   *   issuer: string,\n   *   label: string,\n   *   issuerInLabel: boolean,\n   *   algorithm: string,\n   *   digits: number,\n   *   counter: number\n   *   window: number\n   * }}\n   */\n  static get defaults() {\n    return {\n      issuer: \"\",\n      label: \"OTPAuth\",\n      issuerInLabel: true,\n      algorithm: \"SHA1\",\n      digits: 6,\n      counter: 0,\n      window: 1,\n    };\n  }\n\n  /**\n   * Creates an HOTP object.\n   * @param {Object} [config] Configuration options.\n   * @param {string} [config.issuer=''] Account provider.\n   * @param {string} [config.label='OTPAuth'] Account label.\n   * @param {boolean} [config.issuerInLabel=true] Include issuer prefix in label.\n   * @param {Secret|string} [config.secret=Secret] Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.counter=0] Initial counter value.\n   */\n  constructor({\n    issuer = HOTP.defaults.issuer,\n    label = HOTP.defaults.label,\n    issuerInLabel = HOTP.defaults.issuerInLabel,\n    secret = new Secret(),\n    algorithm = HOTP.defaults.algorithm,\n    digits = HOTP.defaults.digits,\n    counter = HOTP.defaults.counter,\n  } = {}) {\n    /**\n     * Account provider.\n     * @type {string}\n     */\n    this.issuer = issuer;\n    /**\n     * Account label.\n     * @type {string}\n     */\n    this.label = label;\n    /**\n     * Include issuer prefix in label.\n     * @type {boolean}\n     */\n    this.issuerInLabel = issuerInLabel;\n    /**\n     * Secret key.\n     * @type {Secret}\n     */\n    this.secret =\n      typeof secret === \"string\" ? Secret.fromBase32(secret) : secret;\n    /**\n     * HMAC hashing algorithm.\n     * @type {string}\n     */\n    this.algorithm = algorithm.toUpperCase();\n    /**\n     * Token length.\n     * @type {number}\n     */\n    this.digits = digits;\n    /**\n     * Initial counter value.\n     * @type {number}\n     */\n    this.counter = counter;\n  }\n\n  /**\n   * Generates an HOTP token.\n   * @param {Object} config Configuration options.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.counter=0] Counter value.\n   * @returns {Promise<string>} Token.\n   */\n  static async generate({\n    secret,\n    algorithm = HOTP.defaults.algorithm,\n    digits = HOTP.defaults.digits,\n    counter = HOTP.defaults.counter,\n  }) {\n    const digest = new Uint8Array(\n      await hmacDigest(algorithm, secret.buffer, uintToBuf(counter)),\n    );\n    const offset = digest[digest.byteLength - 1] & 15;\n    const otp =\n      (((digest[offset] & 127) << 24) |\n        ((digest[offset + 1] & 255) << 16) |\n        ((digest[offset + 2] & 255) << 8) |\n        (digest[offset + 3] & 255)) %\n      10 ** digits;\n\n    return otp.toString().padStart(digits, \"0\");\n  }\n\n  /**\n   * Generates an HOTP token.\n   * @param {Object} [config] Configuration options.\n   * @param {number} [config.counter=this.counter++] Counter value.\n   * @returns {Promise<string>} Token.\n   */\n  generate({ counter = this.counter++ } = {}) {\n    return HOTP.generate({\n      secret: this.secret,\n      algorithm: this.algorithm,\n      digits: this.digits,\n      counter,\n    });\n  }\n\n  /**\n   * Validates an HOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} config.digits Token length.\n   * @param {number} [config.counter=0] Counter value.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {Promise<number|null>} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */\n  static async validate({\n    token,\n    secret,\n    algorithm,\n    digits,\n    counter = HOTP.defaults.counter,\n    window = HOTP.defaults.window,\n  }) {\n    // Return early if the token length does not match the digit number.\n    if (token.length !== digits) return null;\n\n    let delta = null;\n\n    for (let i = counter - window; i <= counter + window; ++i) {\n      const generatedToken = await HOTP.generate({\n        secret,\n        algorithm,\n        digits,\n        counter: i,\n      });\n\n      if (timingSafeEqual(token, generatedToken)) {\n        delta = i - counter;\n      }\n    }\n\n    return delta;\n  }\n\n  /**\n   * Validates an HOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {number} [config.counter=this.counter] Counter value.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {Promise<number|null>} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */\n  validate({ token, counter = this.counter, window }) {\n    return HOTP.validate({\n      token,\n      secret: this.secret,\n      algorithm: this.algorithm,\n      digits: this.digits,\n      counter,\n      window,\n    });\n  }\n\n  /**\n   * Returns a Google Authenticator key URI.\n   * @returns {string} URI.\n   */\n  toString() {\n    const e = encodeURIComponent;\n    return (\n      \"otpauth://hotp/\" +\n      `${\n        this.issuer.length > 0\n          ? this.issuerInLabel\n            ? `${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`\n            : `${e(this.label)}?issuer=${e(this.issuer)}&`\n          : `${e(this.label)}?`\n      }` +\n      `secret=${e(this.secret.base32)}&` +\n      `algorithm=${e(this.algorithm)}&` +\n      `digits=${e(this.digits)}&` +\n      `counter=${e(this.counter)}`\n    );\n  }\n}\n\nexport { HOTP };\n","import { HOTP } from \"./hotp.js\";\nimport { Secret } from \"./secret.js\";\n\n/**\n * TOTP: Time-Based One-Time Password Algorithm.\n * @see [RFC 6238](https://tools.ietf.org/html/rfc6238)\n */\nclass TOTP {\n  /**\n   * Default configuration.\n   * @type {{\n   *   issuer: string,\n   *   label: string,\n   *   issuerInLabel: boolean,\n   *   algorithm: string,\n   *   digits: number,\n   *   period: number\n   *   window: number\n   * }}\n   */\n  static get defaults() {\n    return {\n      issuer: \"\",\n      label: \"OTPAuth\",\n      issuerInLabel: true,\n      algorithm: \"SHA1\",\n      digits: 6,\n      period: 30,\n      window: 1,\n    };\n  }\n\n  /**\n   * Creates a TOTP object.\n   * @param {Object} [config] Configuration options.\n   * @param {string} [config.issuer=''] Account provider.\n   * @param {string} [config.label='OTPAuth'] Account label.\n   * @param {boolean} [config.issuerInLabel=true] Include issuer prefix in label.\n   * @param {Secret|string} [config.secret=Secret] Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.period=30] Token time-step duration.\n   */\n  constructor({\n    issuer = TOTP.defaults.issuer,\n    label = TOTP.defaults.label,\n    issuerInLabel = TOTP.defaults.issuerInLabel,\n    secret = new Secret(),\n    algorithm = TOTP.defaults.algorithm,\n    digits = TOTP.defaults.digits,\n    period = TOTP.defaults.period,\n  } = {}) {\n    /**\n     * Account provider.\n     * @type {string}\n     */\n    this.issuer = issuer;\n    /**\n     * Account label.\n     * @type {string}\n     */\n    this.label = label;\n    /**\n     * Include issuer prefix in label.\n     * @type {boolean}\n     */\n    this.issuerInLabel = issuerInLabel;\n    /**\n     * Secret key.\n     * @type {Secret}\n     */\n    this.secret =\n      typeof secret === \"string\" ? Secret.fromBase32(secret) : secret;\n    /**\n     * HMAC hashing algorithm.\n     * @type {string}\n     */\n    this.algorithm = algorithm.toUpperCase();\n    /**\n     * Token length.\n     * @type {number}\n     */\n    this.digits = digits;\n    /**\n     * Token time-step duration.\n     * @type {number}\n     */\n    this.period = period;\n  }\n\n  /**\n   * Generates a TOTP token.\n   * @param {Object} config Configuration options.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.period=30] Token time-step duration.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @returns {Promise<string>} Token.\n   */\n  static generate({\n    secret,\n    algorithm,\n    digits,\n    period = TOTP.defaults.period,\n    timestamp = Date.now(),\n  }) {\n    return HOTP.generate({\n      secret,\n      algorithm,\n      digits,\n      counter: Math.floor(timestamp / 1000 / period),\n    });\n  }\n\n  /**\n   * Generates a TOTP token.\n   * @param {Object} [config] Configuration options.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @returns {Promise<string>} Token.\n   */\n  generate({ timestamp = Date.now() } = {}) {\n    return TOTP.generate({\n      secret: this.secret,\n      algorithm: this.algorithm,\n      digits: this.digits,\n      period: this.period,\n      timestamp,\n    });\n  }\n\n  /**\n   * Validates a TOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} config.digits Token length.\n   * @param {number} [config.period=30] Token time-step duration.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {Promise<number|null>} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */\n  static validate({\n    token,\n    secret,\n    algorithm,\n    digits,\n    period = TOTP.defaults.period,\n    timestamp = Date.now(),\n    window,\n  }) {\n    return HOTP.validate({\n      token,\n      secret,\n      algorithm,\n      digits,\n      counter: Math.floor(timestamp / 1000 / period),\n      window,\n    });\n  }\n\n  /**\n   * Validates a TOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {Promise<number|null>} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */\n  validate({ token, timestamp, window }) {\n    return TOTP.validate({\n      token,\n      secret: this.secret,\n      algorithm: this.algorithm,\n      digits: this.digits,\n      period: this.period,\n      timestamp,\n      window,\n    });\n  }\n\n  /**\n   * Returns a Google Authenticator key URI.\n   * @returns {string} URI.\n   */\n  toString() {\n    const e = encodeURIComponent;\n    return (\n      \"otpauth://totp/\" +\n      `${\n        this.issuer.length > 0\n          ? this.issuerInLabel\n            ? `${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`\n            : `${e(this.label)}?issuer=${e(this.issuer)}&`\n          : `${e(this.label)}?`\n      }` +\n      `secret=${e(this.secret.base32)}&` +\n      `algorithm=${e(this.algorithm)}&` +\n      `digits=${e(this.digits)}&` +\n      `period=${e(this.period)}`\n    );\n  }\n}\n\nexport { TOTP };\n","import { HOTP } from \"./hotp.js\";\nimport { TOTP } from \"./totp.js\";\n\n/**\n * Key URI regex (otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS).\n * @type {RegExp}\n */\nconst OTPURI_REGEX =\n  /^otpauth:\\/\\/([ht]otp)\\/(.+)\\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i;\n\n/**\n * RFC 4648 base32 alphabet with pad.\n * @type {RegExp}\n */\nconst SECRET_REGEX = /^[2-7A-Z]+=*$/i;\n\n/**\n * Regex for supported algorithms.\n * @type {RegExp}\n */\nconst ALGORITHM_REGEX = /^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i;\n\n/**\n * Integer regex.\n * @type {RegExp}\n */\nconst INTEGER_REGEX = /^[+-]?\\d+$/;\n\n/**\n * Positive integer regex.\n * @type {RegExp}\n */\nconst POSITIVE_INTEGER_REGEX = /^\\+?[1-9]\\d*$/;\n\n/**\n * HOTP/TOTP object/string conversion.\n * @see [Key URI Format](https://github.com/google/google-authenticator/wiki/Key-Uri-Format)\n */\nclass URI {\n  /**\n   * Parses a Google Authenticator key URI and returns an HOTP/TOTP object.\n   * @param {string} uri Google Authenticator Key URI.\n   * @returns {HOTP|TOTP} HOTP/TOTP object.\n   */\n  static parse(uri) {\n    let uriGroups;\n\n    try {\n      uriGroups = uri.match(OTPURI_REGEX);\n    } catch (error) {\n      /* Handled below */\n    }\n\n    if (!Array.isArray(uriGroups)) {\n      throw new URIError(\"Invalid URI format\");\n    }\n\n    // Extract URI groups.\n    const uriType = uriGroups[1].toLowerCase();\n    const uriLabel = uriGroups[2]\n      .split(/(?::|%3A) *(.+)/i, 2)\n      .map(decodeURIComponent);\n    /** @type {Object.<string, string>} */\n    const uriParams = uriGroups[3].split(\"&\").reduce((acc, cur) => {\n      const pairArr = cur.split(/=(.*)/, 2).map(decodeURIComponent);\n      const pairKey = pairArr[0].toLowerCase();\n      const pairVal = pairArr[1];\n      /** @type {Object.<string, string>} */\n      const pairAcc = acc;\n\n      pairAcc[pairKey] = pairVal;\n      return pairAcc;\n    }, {});\n\n    // 'OTP' will be instantiated with 'config' argument.\n    let OTP;\n    const config = {};\n\n    if (uriType === \"hotp\") {\n      OTP = HOTP;\n\n      // Counter: required\n      if (\n        typeof uriParams.counter !== \"undefined\" &&\n        INTEGER_REGEX.test(uriParams.counter)\n      ) {\n        config.counter = parseInt(uriParams.counter, 10);\n      } else {\n        throw new TypeError(\"Missing or invalid 'counter' parameter\");\n      }\n    } else if (uriType === \"totp\") {\n      OTP = TOTP;\n\n      // Period: optional\n      if (typeof uriParams.period !== \"undefined\") {\n        if (POSITIVE_INTEGER_REGEX.test(uriParams.period)) {\n          config.period = parseInt(uriParams.period, 10);\n        } else {\n          throw new TypeError(\"Invalid 'period' parameter\");\n        }\n      }\n    } else {\n      throw new TypeError(\"Unknown OTP type\");\n    }\n\n    // Label: required\n    // Issuer: optional\n    if (typeof uriParams.issuer !== \"undefined\") {\n      config.issuer = uriParams.issuer;\n    }\n    if (uriLabel.length === 2) {\n      config.label = uriLabel[1];\n      if (typeof config.issuer === \"undefined\" || config.issuer === \"\") {\n        config.issuer = uriLabel[0];\n      } else if (uriLabel[0] === \"\") {\n        config.issuerInLabel = false;\n      }\n    } else {\n      config.label = uriLabel[0];\n      if (typeof config.issuer !== \"undefined\" && config.issuer !== \"\") {\n        config.issuerInLabel = false;\n      }\n    }\n\n    // Secret: required\n    if (\n      typeof uriParams.secret !== \"undefined\" &&\n      SECRET_REGEX.test(uriParams.secret)\n    ) {\n      config.secret = uriParams.secret;\n    } else {\n      throw new TypeError(\"Missing or invalid 'secret' parameter\");\n    }\n\n    // Algorithm: optional\n    if (typeof uriParams.algorithm !== \"undefined\") {\n      if (ALGORITHM_REGEX.test(uriParams.algorithm)) {\n        config.algorithm = uriParams.algorithm;\n      } else {\n        throw new TypeError(\"Invalid 'algorithm' parameter\");\n      }\n    }\n\n    // Digits: optional\n    if (typeof uriParams.digits !== \"undefined\") {\n      if (POSITIVE_INTEGER_REGEX.test(uriParams.digits)) {\n        config.digits = parseInt(uriParams.digits, 10);\n      } else {\n        throw new TypeError(\"Invalid 'digits' parameter\");\n      }\n    }\n\n    return new OTP(config);\n  }\n\n  /**\n   * Converts an HOTP/TOTP object to a Google Authenticator key URI.\n   * @param {HOTP|TOTP} otp HOTP/TOTP object.\n   * @returns {string} Google Authenticator Key URI.\n   */\n  static stringify(otp) {\n    if (otp instanceof HOTP || otp instanceof TOTP) {\n      return otp.toString();\n    }\n\n    throw new TypeError(\"Invalid 'HOTP/TOTP' object\");\n  }\n}\n\nexport { URI };\n","/**\n * Library version.\n * @type {string}\n */\nconst version = \"__OTPAUTH_VERSION__\";\n\nexport { version };\n"],"names":["uintToBuf","num","buf","ArrayBuffer","arr","Uint8Array","acc","i","globalScope","globalThis","Object","defineProperty","prototype","get","configurable","__GLOBALTHIS__","self","window","global","S","o","e","n","H","a","A","r","f","t","OPENSSL_JSSHA_ALGO_MAP","SHA1","SHA224","SHA256","SHA384","SHA512","hmacDigest","algorithm","key","message","__async","_a","_b","crypto","createHmac","hmac","Buffer","from","update","digest","buffer","variant","toUpperCase","TypeError","subtle","name","hash","hmacKey","importKey","sign","jsSHA","setHMACKey","getHMAC","ALPHABET","base32ToBuf","str","end","length","cstr","substring","bits","value","index","idx","indexOf","base32FromBuf","hexToBuf","parseInt","hexFromBuf","hex","toString","latin1ToBuf","charCodeAt","latin1FromBuf","String","fromCharCode","ENCODER","TextEncoder","DECODER","TextDecoder","utf8ToBuf","Error","encode","utf8FromBuf","decode","randomBytes","size","getRandomValues","Secret","constructor","fromLatin1","fromUTF8","fromBase32","fromHex","latin1","enumerable","utf8","base32","timingSafeEqual","b","out","e$1","HOTP","defaults","issuer","label","issuerInLabel","digits","counter","secret","generate","_0","offset","byteLength","__pow","padStart","validate","token","delta","generatedToken","encodeURIComponent","TOTP","period","timestamp","Date","now","Math","floor","OTPURI_REGEX","SECRET_REGEX","ALGORITHM_REGEX","INTEGER_REGEX","POSITIVE_INTEGER_REGEX","URI","parse","uri","uriGroups","match","error","Array","isArray","URIError","uriType","toLowerCase","uriLabel","split","map","decodeURIComponent","uriParams","reduce","cur","pairArr","pairKey","pairVal","pairAcc","OTP","config","test","stringify","otp","version"],"mappings":"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"}