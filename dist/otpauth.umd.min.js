/// <reference types="./otpauth.d.ts" />
(function(c,p){typeof exports=="object"&&typeof module!="undefined"?p(exports):typeof define=="function"&&define.amd?define(["exports"],p):(c=typeof globalThis!="undefined"?globalThis:c||self,p(c.OTPAuth={}))})(this,function(c){"use strict";const p=o=>{const e=new ArrayBuffer(8),t=new Uint8Array(e);let r=o;for(let n=7;n>=0&&r!==0;n--)t[n]=r&255,r-=t[n],r/=256;return e};var y=Object.freeze({__proto__:null,createHmac:void 0,randomBytes:void 0,timingSafeEqual:void 0});const g=(()=>{if(typeof globalThis=="object")return globalThis;Object.defineProperty(Object.prototype,"__GLOBALTHIS__",{get(){return this},configurable:!0});try{if(typeof __GLOBALTHIS__!="undefined")return __GLOBALTHIS__}finally{delete Object.prototype.__GLOBALTHIS__}if(typeof self!="undefined")return self;if(typeof window!="undefined")return window;if(typeof global!="undefined")return global})();var H=(o,e,t)=>new Promise((r,n)=>{var i=l=>{try{s(t.next(l))}catch(u){n(u)}},a=l=>{try{s(t.throw(l))}catch(u){n(u)}},s=l=>l.done?r(l.value):Promise.resolve(l.value).then(i,a);s((t=t.apply(o,e)).next())});const T={SHA1:"SHA-1",SHA224:"SHA-224",SHA256:"SHA-256",SHA384:"SHA-384",SHA512:"SHA-512","SHA3-224":"SHA3-224","SHA3-256":"SHA3-256","SHA3-384":"SHA3-384","SHA3-512":"SHA3-512"},E=(o,e,t)=>H(void 0,null,function*(){var r,n;y!=null;const i=T[o.toUpperCase()];if(typeof i=="undefined")throw new TypeError("Unknown hash function");if((n=(r=g)==null?void 0:r.crypto)!=null&&n.subtle){const a=g.crypto,s={name:"HMAC",hash:i},l=yield a.subtle.importKey("raw",e,s,!1,["sign"]);return yield a.subtle.sign(s,l,t)}else throw new Error("a")}),b="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",L=o=>{let e=o.length;for(;o[e-1]==="=";)--e;const t=(e<o.length?o.substring(0,e):o).toUpperCase(),r=new ArrayBuffer(t.length*5/8|0),n=new Uint8Array(r);let i=0,a=0,s=0;for(let l=0;l<t.length;l++){const u=b.indexOf(t[l]);if(u===-1)throw new TypeError(`Invalid character found: ${t[l]}`);a=a<<5|u,i+=5,i>=8&&(i-=8,n[s++]=a>>>i)}return r},U=o=>{const e=new Uint8Array(o);let t=0,r=0,n="";for(let i=0;i<e.length;i++)for(r=r<<8|e[i],t+=8;t>=5;)n+=b[r>>>t-5&31],t-=5;return t>0&&(n+=b[r<<5-t&31]),n},O=o=>{const e=new ArrayBuffer(o.length/2),t=new Uint8Array(e);for(let r=0;r<o.length;r+=2)t[r/2]=parseInt(o.substring(r,r+2),16);return e},B=o=>{const e=new Uint8Array(o);let t="";for(let r=0;r<e.length;r++){const n=e[r].toString(16);n.length===1&&(t+="0"),t+=n}return t.toUpperCase()},P=o=>{const e=new ArrayBuffer(o.length),t=new Uint8Array(e);for(let r=0;r<o.length;r++)t[r]=o.charCodeAt(r)&255;return e},C=o=>{const e=new Uint8Array(o);let t="";for(let r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},A=g.TextEncoder?new g.TextEncoder("utf-8"):null,$=g.TextDecoder?new g.TextDecoder("utf-8"):null,x=o=>{if(!A)throw new Error("Encoding API not available");return A.encode(o).buffer},j=o=>{if(!$)throw new Error("Encoding API not available");return $.decode(o)},R=o=>{var e;if(y!=null,!((e=g.crypto)!=null&&e.getRandomValues))throw new Error("Cryptography API not available");return g.crypto.getRandomValues(new Uint8Array(o)).buffer};class h{constructor({buffer:e,size:t=20}={}){this.buffer=typeof e=="undefined"?R(t):e}static fromLatin1(e){return new h({buffer:P(e)})}static fromUTF8(e){return new h({buffer:x(e)})}static fromBase32(e){return new h({buffer:L(e)})}static fromHex(e){return new h({buffer:O(e)})}get latin1(){return Object.defineProperty(this,"latin1",{enumerable:!0,value:C(this.buffer)}),this.latin1}get utf8(){return Object.defineProperty(this,"utf8",{enumerable:!0,value:j(this.buffer)}),this.utf8}get base32(){return Object.defineProperty(this,"base32",{enumerable:!0,value:U(this.buffer)}),this.base32}get hex(){return Object.defineProperty(this,"hex",{enumerable:!0,value:B(this.buffer)}),this.hex}}const k=(o,e)=>{y!=null;{if(o.length!==e.length)throw new TypeError("Input strings must have the same length");let t=-1,r=0;for(;++t<o.length;)r|=o.charCodeAt(t)^e.charCodeAt(t);return r===0}};var M=Math.pow,v=(o,e,t)=>new Promise((r,n)=>{var i=l=>{try{s(t.next(l))}catch(u){n(u)}},a=l=>{try{s(t.throw(l))}catch(u){n(u)}},s=l=>l.done?r(l.value):Promise.resolve(l.value).then(i,a);s((t=t.apply(o,e)).next())});let m=class f{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,counter:0,window:1}}constructor({issuer:e=f.defaults.issuer,label:t=f.defaults.label,issuerInLabel:r=f.defaults.issuerInLabel,secret:n=new h,algorithm:i=f.defaults.algorithm,digits:a=f.defaults.digits,counter:s=f.defaults.counter}={}){this.issuer=e,this.label=t,this.issuerInLabel=r,this.secret=typeof n=="string"?h.fromBase32(n):n,this.algorithm=i.toUpperCase(),this.digits=a,this.counter=s}static generate(e){return v(this,arguments,function*({secret:t,algorithm:r=f.defaults.algorithm,digits:n=f.defaults.digits,counter:i=f.defaults.counter}){const a=new Uint8Array(yield E(r,t.buffer,p(i))),s=a[a.byteLength-1]&15;return(((a[s]&127)<<24|(a[s+1]&255)<<16|(a[s+2]&255)<<8|a[s+3]&255)%M(10,n)).toString().padStart(n,"0")})}generate({counter:e=this.counter++}={}){return f.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:e})}static validate(e){return v(this,arguments,function*({token:t,secret:r,algorithm:n,digits:i,counter:a=f.defaults.counter,window:s=f.defaults.window}){if(t.length!==i)return null;let l=null;for(let u=a-s;u<=a+s;++u){const w=yield f.generate({secret:r,algorithm:n,digits:i,counter:u});k(t,w)&&(l=u-a)}return l})}validate({token:e,counter:t=this.counter,window:r}){return f.validate({token:e,secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:t,window:r})}toString(){const e=encodeURIComponent;return`otpauth://hotp/${this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`}secret=${e(this.secret.base32)}&algorithm=${e(this.algorithm)}&digits=${e(this.digits)}&counter=${e(this.counter)}`}};class d{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,period:30,window:1}}constructor({issuer:e=d.defaults.issuer,label:t=d.defaults.label,issuerInLabel:r=d.defaults.issuerInLabel,secret:n=new h,algorithm:i=d.defaults.algorithm,digits:a=d.defaults.digits,period:s=d.defaults.period}={}){this.issuer=e,this.label=t,this.issuerInLabel=r,this.secret=typeof n=="string"?h.fromBase32(n):n,this.algorithm=i.toUpperCase(),this.digits=a,this.period=s}static generate({secret:e,algorithm:t,digits:r,period:n=d.defaults.period,timestamp:i=Date.now()}){return m.generate({secret:e,algorithm:t,digits:r,counter:Math.floor(i/1e3/n)})}generate({timestamp:e=Date.now()}={}){return d.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:e})}static validate({token:e,secret:t,algorithm:r,digits:n,period:i=d.defaults.period,timestamp:a=Date.now(),window:s}){return m.validate({token:e,secret:t,algorithm:r,digits:n,counter:Math.floor(a/1e3/i),window:s})}validate({token:e,timestamp:t,window:r}){return d.validate({token:e,secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:t,window:r})}toString(){const e=encodeURIComponent;return`otpauth://totp/${this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`}secret=${e(this.secret.base32)}&algorithm=${e(this.algorithm)}&digits=${e(this.digits)}&period=${e(this.period)}`}}const D=/^otpauth:\/\/([ht]otp)\/(.+)\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i,q=/^[2-7A-Z]+=*$/i,G=/^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i,Z=/^[+-]?\d+$/,S=/^\+?[1-9]\d*$/;class V{static parse(e){let t;try{t=e.match(D)}catch(l){}if(!Array.isArray(t))throw new URIError("Invalid URI format");const r=t[1].toLowerCase(),n=t[2].split(/(?::|%3A) *(.+)/i,2).map(decodeURIComponent),i=t[3].split("&").reduce((l,u)=>{const w=u.split(/=(.*)/,2).map(decodeURIComponent),F=w[0].toLowerCase(),K=w[1],I=l;return I[F]=K,I},{});let a;const s={};if(r==="hotp")if(a=m,typeof i.counter!="undefined"&&Z.test(i.counter))s.counter=parseInt(i.counter,10);else throw new TypeError("Missing or invalid 'counter' parameter");else if(r==="totp"){if(a=d,typeof i.period!="undefined")if(S.test(i.period))s.period=parseInt(i.period,10);else throw new TypeError("Invalid 'period' parameter")}else throw new TypeError("Unknown OTP type");if(typeof i.issuer!="undefined"&&(s.issuer=i.issuer),n.length===2?(s.label=n[1],typeof s.issuer=="undefined"||s.issuer===""?s.issuer=n[0]:n[0]===""&&(s.issuerInLabel=!1)):(s.label=n[0],typeof s.issuer!="undefined"&&s.issuer!==""&&(s.issuerInLabel=!1)),typeof i.secret!="undefined"&&q.test(i.secret))s.secret=i.secret;else throw new TypeError("Missing or invalid 'secret' parameter");if(typeof i.algorithm!="undefined")if(G.test(i.algorithm))s.algorithm=i.algorithm;else throw new TypeError("Invalid 'algorithm' parameter");if(typeof i.digits!="undefined")if(S.test(i.digits))s.digits=parseInt(i.digits,10);else throw new TypeError("Invalid 'digits' parameter");return new a(s)}static stringify(e){if(e instanceof m||e instanceof d)return e.toString();throw new TypeError("Invalid 'HOTP/TOTP' object")}}const z="9.2.2";c.HOTP=m,c.Secret=h,c.TOTP=d,c.URI=V,c.version=z});
//# sourceMappingURL=otpauth.umd.min.js.map
